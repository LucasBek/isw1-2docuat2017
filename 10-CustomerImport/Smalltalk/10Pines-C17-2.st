TestCase subclass: #CustomerImportTest	instanceVariableNames: 'session importer system testData'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Test'!!CustomerImportTest methodsFor: 'setup-teardown' stamp: 'LJ 11/13/2017 21:13'!tearDown	system commit.	system stop.! !!CustomerImportTest methodsFor: 'testing' stamp: 'LJ 11/22/2017 23:09'!testCanNotImportAddressRecordWithMoreThanSixFields	self		should: [ self				importCustomersFrom: testData addressRecordWithMoreThanSixFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: AddressRecordImporter invalidAddressRecordErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'LJ 11/22/2017 22:55'!testShouldNotImportAddressRecordsStartingWithMoreThanA	self		should: [ self				importCustomersFrom: testData addressRecordStartingWithMoreThanOneATestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: CsvImporter invalidRecordTypeErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'LJ 11/21/2017 23:09'!testImportCustomers	self importCustomersFrom: testData validCustomerTestData.	self assertImportedCustomersSizeIsCorrect.	self assertPepeSanchezWasImportedCorrectly.	self assertJuanPerezWasImportedCorrectly! !!CustomerImportTest methodsFor: 'testing' stamp: 'LJ 11/23/2017 00:16'!testImportCustomerWithSameIdShouldFail	self importCustomersFrom: testData validCustomerTestData.	self		should: [ self importCustomersFrom: testData validCustomerTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self assert: anError messageText equals: CustomerSystem alreadyTakenIdentificationError.			self assert: system allCustomersSize equals: 2 ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'LJ 11/22/2017 22:55'!testShouldNotImportCustomerRecordsStartingWithMoreThanC	self		should: [ self				importCustomersFrom: testData customerRecordStartingWithMoreThanOneCTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: CsvImporter invalidRecordTypeErrorDescription.			self assert: self customersIsEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'LJ 11/22/2017 23:09'!testCanNotImportCustomerRecordWithLessThanFiveFields	self		should: [ self				importCustomersFrom: testData customerRecordWithLessThanFiveFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: CustomerRecordImporter invalidCustomerRecordErrorDescription.			self assert: self customersIsEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'LJ 11/22/2017 22:55'!testEmptyLinesAreRecognizedAsInvalidRecords	self		should: [ self importCustomersFrom: testData dataWithEmptyLine ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: CsvImporter invalidRecordTypeErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'LJ 11/22/2017 23:17'!testCanNotImportAddressWithoutCustomer	self		should: [ self importCustomersFrom: testData addressWithoutCustomerTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: CustomerImporter noCustomerBeforeAddressError.			self assert: self customersIsEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'LJ 11/22/2017 23:09'!testCanNotImportCustomerRecordWithMoreThanFiveFields	self		should: [ self				importCustomersFrom: testData customerRecordWithMoreThanFiveFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: CustomerRecordImporter invalidCustomerRecordErrorDescription.			self assert: self customersIsEmpty ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'LJ 11/22/2017 23:09'!testCanNotImportAddressRecordWithLessThanSixFields	self		should: [ self				importCustomersFrom: testData addressRecordWithLessThanSixFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: AddressRecordImporter invalidAddressRecordErrorDescription.			self assert: self alwaysImportedCustomer addressesIsEmpty ]! !!CustomerImportTest methodsFor: 'importing' stamp: 'LJ 11/22/2017 23:12'!importCustomersFrom: inputStream	(CsvImporter		from: inputStream		withImporter: (CustomerImporter withSystem: system)) import! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'LJ 11/16/2017 19:07'!customersIsEmpty	^ system allCustomersIsEmpty.! !!CustomerImportTest methodsFor: 'test data - customer' stamp: 'LJ 11/21/2017 23:29'!alwaysImportedCustomer	^ self		customerIdentifiedAs: testData alwaysImportedCustomerIdentification! !!CustomerImportTest methodsFor: 'initialization' stamp: 'LJ 11/21/2017 23:02'!setUp	system := Environment current createErpSystem.	system start.	system beginTransaction.	testData := ImporterTestData new.! !!CustomerImportTest methodsFor: 'identification' stamp: 'LJ 11/20/2017 21:58'!customerIdentifiedAs: anId	^ system customerIdentifiedAs: anId! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/1/2016 11:00'!assert: customer hasAddressAt: streetName number: streetNumber in: town zipCode: zipCode province: province	| address |		address := customer addressAt: streetName ifNone: [ self fail ].	self assert: address streetName equals: streetName.	self assert: address streetNumber equals: streetNumber.	self assert: address town equals: town.	self assert: address zipCode equals: zipCode.	self assert: address province equals: province.	! !!CustomerImportTest methodsFor: 'asserting' stamp: 'LJ 11/20/2017 22:38'!assert: aSupplier isNamed: aName andIsIdentifiedAs: anId andNumberOfAddresses: aNumberOfAddresses andNumberOfCustomers: aNumberOfCustomers	self assert: aSupplier name equals: aName.	self assert: (aSupplier isIdentifiedAs: anId). 	self assert: aSupplier numberOfAddresses equals: aNumberOfAddresses.	self assert: aSupplier numberOfCustomers equals: aNumberOfCustomers.! !!CustomerImportTest methodsFor: 'asserting' stamp: 'LJ 11/20/2017 22:25'!assertPepeSanchezWasImportedCorrectly	| customer idType idNumber |	idType := 'D'.	idNumber := '22333444'.	customer := self customerIdentifiedAs: (Identification ofType: idType numbered: idNumber).	self		assert: customer		isNamed: 'Pepe'		lastName: 'Sanchez'		identfiedAs: idType 		withNumber: idNumber		andNumberOfAddresses: 2.		self assertCustomerHasCorrectAddresses: customer.! !!CustomerImportTest methodsFor: 'asserting' stamp: 'LJ 11/20/2017 22:58'!assert: aSupplier hasCustomerIdentifiedAs: anId named: aName lastName: aLastName	| customer |		customer := aSupplier customerIdentifiedAs: anId ifNone: [ self fail ].	self assert: (customer firstName) equals: aName.	self assert: (customer lastName) equals: aLastName.	! !!CustomerImportTest methodsFor: 'asserting' stamp: 'LJ 11/20/2017 22:06'!assertJuanPerezWasImportedCorrectly		| customer idType idNumber |		idType := 'C'.	idNumber := '23-25666777-9'.	customer := self customerIdentifiedAs: (Identification ofType: idType numbered: idNumber).		self assert: customer isNamed: 'Juan' lastName: 'Perez' identfiedAs: idType withNumber: idNumber andNumberOfAddresses: 1.	self assert: customer hasAddressAt: 'Alem' number: 1122 in: 'CABA' zipCode: 1001 province: 'CABA'.	! !!CustomerImportTest methodsFor: 'asserting' stamp: 'LJ 11/20/2017 22:15'!assert: customer isNamed: firstName lastName: lastName identfiedAs: idType withNumber: idNumber andNumberOfAddresses: addressesSize	self assert: customer firstName equals: firstName.	self assert: customer lastName equals: lastName.	self assert: (customer isIdentifiedAs: (Identification ofType: idType numbered: idNumber)).	self assert: customer numberOfAddresses equals: addressesSize! !!CustomerImportTest methodsFor: 'asserting' stamp: 'LJ 11/20/2017 22:26'!assertCustomerHasCorrectAddresses: aCustomer	self assertPartyHasCorrectAddresses: aCustomer. ! !!CustomerImportTest methodsFor: 'asserting' stamp: 'LJ 11/20/2017 22:27'!assertPartyHasCorrectAddresses: aParty	self		assert: aParty		hasAddressAt: 'San Martin'		number: 3322		in: 'Olivos'		zipCode: 1636		province: 'BsAs'.	self		assert: aParty		hasAddressAt: 'Maipu'		number: 888		in: 'Florida'		zipCode: 1122		province: 'Buenos Aires'! !!CustomerImportTest methodsFor: 'asserting' stamp: 'LJ 11/16/2017 19:03'!assertImportedCustomersSizeIsCorrect	self assert: system allCustomersSize equals: 2! !Object subclass: #ImporterTestData	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Test'!!ImporterTestData methodsFor: 'test data - customer' stamp: 'LJ 11/21/2017 23:32'!customerRecordStartingWithMoreThanOneCTestData		^ ReadStream on:'CC,Pepe,Sanchez,D,22333444'! !!ImporterTestData methodsFor: 'test data - customer' stamp: 'LJ 11/21/2017 23:35'!dataWithEmptyLine	^ ReadStream		on:			self alwaysImportedCustomerRecord				,					'A,San Martin,3322,Olivos,1636,BsAs'! !!ImporterTestData methodsFor: 'test data - customer' stamp: 'LJ 11/21/2017 23:33'!customerRecordWithLessThanFiveFieldsTestData		^ ReadStream on: 'C,Pepe,Sanchez,D'! !!ImporterTestData methodsFor: 'test data - customer' stamp: 'LJ 11/21/2017 23:55'!alwaysImportedCustomerTestData	^ ReadStream on: self alwaysImportedCustomerRecord ! !!ImporterTestData methodsFor: 'test data - customer' stamp: 'LJ 11/21/2017 23:33'!customerRecordWithMoreThanFiveFieldsTestData	^ ReadStream on:		self alwaysImportedCustomerRecord , ',x'! !!ImporterTestData methodsFor: 'test data - customer' stamp: 'LJ 11/21/2017 23:29'!alwaysImportedCustomerIdentification	^ Identification		ofType: self alwaysImportedCustomerIdType		numbered: self alwaysImportedCustomerIdNumber! !!ImporterTestData methodsFor: 'test data - customer' stamp: 'LJ 11/21/2017 23:09'!validCustomerTestData	^ ReadStream		on:			self alwaysImportedCustomerRecord				,					'A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!ImporterTestData methodsFor: 'test data - customer' stamp: 'LJ 11/21/2017 23:04'!alwaysImportedCustomerIdType	^ 'D'! !!ImporterTestData methodsFor: 'test data - customer' stamp: 'LJ 11/21/2017 23:05'!alwaysImportedCustomerIdNumber	^ '22333444'! !!ImporterTestData methodsFor: 'test data - customer' stamp: 'LJ 11/21/2017 23:06'!alwaysImportedCustomerRecord	^ 'C,Pepe,Sanchez,' , self alwaysImportedCustomerIdType , ','		, self alwaysImportedCustomerIdNumber! !!ImporterTestData methodsFor: 'test data - new customer' stamp: 'LJ 11/23/2017 01:24'!newCustomerWithAlreadyExistentIdentificationTestData	^ ReadStream on: self alwaysImportedSupplierRecord,'NC,Pepe,Sanchez,D,12222NC,Pepe,Sanchez,D,12222'! !!ImporterTestData methodsFor: 'test data - new customer' stamp: 'LJ 11/22/2017 00:42'!newCustomerWithLessThanFiveFieldsTestData	^ ReadStream on: self alwaysImportedSupplierRecord,'NC,Pepe,Sanchez,D'! !!ImporterTestData methodsFor: 'test data - new customer' stamp: 'LJ 11/22/2017 00:04'!newCustomerWithoutSupplierTestData	^ ReadStream on: 'NC,Pepe,Sanchez,D,22333444'! !!ImporterTestData methodsFor: 'test data - new customer' stamp: 'LJ 11/23/2017 01:24'!newCustomerWithMoreThanFiveFieldsTestData	^ ReadStream on: self alwaysImportedSupplierRecord,'NC,Pepe,Sanchez,D,12222,R'! !!ImporterTestData methodsFor: 'test data - existing customer' stamp: 'LJ 11/22/2017 00:37'!existingCustomerWithLessThanThreeFieldsTestData	^ ReadStream on: self alwaysImportedSupplierRecord,' EC,', self alwaysImportedCustomerIdType! !!ImporterTestData methodsFor: 'test data - existing customer' stamp: 'LJ 11/22/2017 00:40'!existingCustomerWithMoreThanThreeFieldsTestData	^ ReadStream on: self alwaysImportedSupplierRecord,' EC,', self alwaysImportedCustomerIdType, ',123,R'! !!ImporterTestData methodsFor: 'test data - existing customer' stamp: 'LJ 11/22/2017 00:12'!existingCustomerWithoutSupplierTestData	^ ReadStream on: 'EC,', self alwaysImportedCustomerIdType, ',', self alwaysImportedCustomerIdNumber .! !!ImporterTestData methodsFor: 'test data - supplier' stamp: 'LJ 11/21/2017 23:44'!supplierRecordWithMoreThanFourFieldsTestData	^ ReadStream on: 'S,Supplier,D,223,R'! !!ImporterTestData methodsFor: 'test data - supplier' stamp: 'LJ 11/22/2017 00:31'!validSupplierTestData	^ ReadStream		on: self alwaysImportedSupplierRecord				,					'EC,' , self alwaysImportedCustomerIdType , ','				, self alwaysImportedCustomerIdNumber				,					'NC,Pato,Lucas,D,1234A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos Aires'! !!ImporterTestData methodsFor: 'test data - supplier' stamp: 'LJ 11/21/2017 23:07'!alwaysImportedSupplierIdType	^ 'D'! !!ImporterTestData methodsFor: 'test data - supplier' stamp: 'LJ 11/21/2017 23:44'!supplierRecordWithLessThanFourFieldsTestData	^ ReadStream on: 'S,Supplier,D'! !!ImporterTestData methodsFor: 'test data - supplier' stamp: 'LJ 11/21/2017 23:06'!alwaysImportedSupplierNumber	^ '123'! !!ImporterTestData methodsFor: 'test data - supplier' stamp: 'LJ 11/23/2017 01:03'!supplierWithAlreadyExistentIdentificationTestData	^ ReadStream		on: self alwaysImportedSupplierRecord,'', self alwaysImportedSupplierRecord 	! !!ImporterTestData methodsFor: 'test data - supplier' stamp: 'LJ 11/21/2017 23:08'!alwaysImportedSupplierRecord	^ 'S,Supplier1,' , self alwaysImportedSupplierIdType , ','		, self alwaysImportedSupplierNumber! !!ImporterTestData methodsFor: 'test data - supplier' stamp: 'LJ 11/22/2017 00:27'!alwaysImportedSupplierIdentification	^ Identification ofType: self alwaysImportedSupplierIdType numbered: self alwaysImportedSupplierNumber.! !!ImporterTestData methodsFor: 'test data - address' stamp: 'LJ 11/21/2017 23:31'!addressRecordStartingWithMoreThanOneATestData	^ ReadStream		on:			self alwaysImportedCustomerRecord				,					'AA,San Martin,3322,Olivos,1636,BsAs'! !!ImporterTestData methodsFor: 'test data - address' stamp: 'LJ 11/22/2017 00:00'!addressWithoutSupplierTestData		^ ReadStream on: 'A,San Martin,3322,Olivos,1636,BsAs'! !!ImporterTestData methodsFor: 'test data - address' stamp: 'LJ 11/21/2017 23:29'!addressWithoutCustomerTestData		^ ReadStream on: 'A,San Martin,3322,Olivos,1636,BsAs'! !!ImporterTestData methodsFor: 'test data - address' stamp: 'LJ 11/21/2017 23:30'!addressRecordWithMoreThanSixFieldsTestData	^ ReadStream		on:			self alwaysImportedCustomerRecord				,					'A,San Martin,3322,Olivos,1636,BsAs,y otra cosa'! !!ImporterTestData methodsFor: 'test data - address' stamp: 'LJ 11/21/2017 23:31'!addressRecordWithLessThanSixFieldsTestData	^ ReadStream		on:			self alwaysImportedCustomerRecord				,					'A,San Martin,3322,Olivos,1636'! !TestCase subclass: #SupplierImportTest	instanceVariableNames: 'session importer system testData'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Test'!!SupplierImportTest methodsFor: 'test-data customer' stamp: 'LJ 11/22/2017 00:24'!customersIsEmpty	^ system allCustomersIsEmpty.! !!SupplierImportTest methodsFor: 'tests' stamp: 'LJ 11/22/2017 23:44'!testCanNotImportNewCustomerRecordWithoutSupplier	self		should: [ self				importSuppliersFrom:  testData newCustomerWithoutSupplierTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter noSupplierBeforeNewCustomerError   .			self assert: self customersIsEmpty  ]! !!SupplierImportTest methodsFor: 'tests' stamp: 'LJ 11/23/2017 01:18'!testCanNotImportSupplierWithAlreadyExistentIdentification	self		should: [ self				importSuppliersFrom: testData supplierWithAlreadyExistentIdentificationTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierSystem alreadyTakenIdentificationError  .			self assert: system allSuppliersSize equals: 1]! !!SupplierImportTest methodsFor: 'tests' stamp: 'LJ 11/22/2017 23:10'!testCanNotImportSupplierRecordWithMoreThanFourFields	self		should: [ self				importSuppliersFrom: testData supplierRecordWithMoreThanFourFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierRecordImporter invalidSupplierRecordErrorDescription .			self assert: self suppliersIsEmpty ]! !!SupplierImportTest methodsFor: 'tests' stamp: 'LJ 11/22/2017 23:44'!testCanNotImportCustomerRecordWithSupplierImporter	self		should: [ self				importSuppliersFrom:  testData alwaysImportedCustomerTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: CsvImporter invalidRecordTypeErrorDescription .			self assert: self customersIsEmpty  ]! !!SupplierImportTest methodsFor: 'tests' stamp: 'LJ 11/23/2017 01:21'!testCanNotImportNewCustomerWithAlreadyExistentIdentification	self		should: [ self				importSuppliersFrom: testData newCustomerWithAlreadyExistentIdentificationTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: CustomerSystem alreadyTakenIdentificationError  .			self assert: system allSuppliersSize equals: 1]! !!SupplierImportTest methodsFor: 'tests' stamp: 'LJ 11/22/2017 23:10'!testCanNotImportNewCustomerWithLessThanFiveFields	self		should: [ self				importSuppliersFrom: testData newCustomerWithLessThanFiveFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals:  NewCustomerRecordImporter invalidNewCustomerRecordErrorDescription   .			self assert: self customersIsEmpty  ]! !!SupplierImportTest methodsFor: 'tests' stamp: 'LJ 11/22/2017 23:55'!testCanNotImportExistingCustomerRecordWithoutSupplier	self		should: [ self importSuppliersFrom:  testData existingCustomerWithoutSupplierTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter noSupplierBeforeExistingCustomerError   .			self assert: self customersIsEmpty   ]! !!SupplierImportTest methodsFor: 'tests' stamp: 'LJ 11/22/2017 23:10'!testCanNotImportExistingCustomerWithLessThanThreeFields	self		should: [ self				importSuppliersFrom: testData existingCustomerWithLessThanThreeFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: ExistingCustomerRecordImporter  invalidExistingCustomerRecordErrorDescription  .			self assert: self customersIsEmpty  ]! !!SupplierImportTest methodsFor: 'tests' stamp: 'LJ 11/22/2017 00:29'!testCanNotImportInexistentCustomerAsExistingCustomerRecord	self		should: [	self importSuppliersFrom:  testData validSupplierTestData  ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: CustomerSystem customerDoesNotExistError .			self assert: self alwaysImportedSupplier customersIsEmpty  ]! !!SupplierImportTest methodsFor: 'tests' stamp: 'LJ 11/21/2017 23:55'!testImportSupplier	self importCustomersFrom: testData alwaysImportedCustomerTestData.	self importSuppliersFrom: testData validSupplierTestData.	self assertImportedSuppliersSizeIsCorrect.	self assertImportedCustomersSizeIsCorrect.	self assertSupplier1WasImportedCorrectly! !!SupplierImportTest methodsFor: 'tests' stamp: 'LJ 11/22/2017 23:10'!testCanNotImportNewCustomerWithMoreThanFiveFields	self		should: [ self				importSuppliersFrom: testData newCustomerWithMoreThanFiveFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals:  NewCustomerRecordImporter invalidNewCustomerRecordErrorDescription   .			self assert: self customersIsEmpty  ]! !!SupplierImportTest methodsFor: 'tests' stamp: 'LJ 11/22/2017 23:10'!testCanNotImportSupplierRecordWithLessThanFourFields	self		should: [ self				importSuppliersFrom: testData supplierRecordWithLessThanFourFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierRecordImporter invalidSupplierRecordErrorDescription .			self assert: self suppliersIsEmpty ]! !!SupplierImportTest methodsFor: 'tests' stamp: 'LJ 11/22/2017 23:39'!testCanNotImportAddressRecordWithoutSupplier	self		should: [ self				importSuppliersFrom:  testData addressWithoutSupplierTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: SupplierImporter noSupplierBeforeAddressesError  .			self assert: self suppliersIsEmpty ]! !!SupplierImportTest methodsFor: 'tests' stamp: 'LJ 11/22/2017 23:10'!testCanNotImportExistingCustomerWithMoreThanThreeFields	self		should: [ self				importSuppliersFrom: testData existingCustomerWithMoreThanThreeFieldsTestData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self				assert: anError messageText				equals: ExistingCustomerRecordImporter  invalidExistingCustomerRecordErrorDescription  .			self assert: self customersIsEmpty  ]! !!SupplierImportTest methodsFor: 'test data - supplier' stamp: 'LJ 11/21/2017 23:45'!suppliersIsEmpty	^ system allSuppliersIsEmpty.! !!SupplierImportTest methodsFor: 'test data - supplier' stamp: 'LJ 11/22/2017 00:26'!alwaysImportedSupplier	^ self		supplierIdentifiedAs: testData alwaysImportedSupplierIdentification! !!SupplierImportTest methodsFor: 'setup-teardown' stamp: 'LJ 11/21/2017 23:03'!setUp	system := Environment current createErpSystem.	system start.	system beginTransaction.	testData := ImporterTestData new.! !!SupplierImportTest methodsFor: 'setup-teardown' stamp: 'LJ 11/21/2017 22:54'!tearDown	system commit.	system stop.! !!SupplierImportTest methodsFor: 'asserting' stamp: 'LJ 11/21/2017 23:27'!assert: customer hasAddressAt: streetName number: streetNumber in: town zipCode: zipCode province: province	| address |		address := customer addressAt: streetName ifNone: [ self fail ].	self assert: address streetName equals: streetName.	self assert: address streetNumber equals: streetNumber.	self assert: address town equals: town.	self assert: address zipCode equals: zipCode.	self assert: address province equals: province.	! !!SupplierImportTest methodsFor: 'asserting' stamp: 'LJ 11/21/2017 23:20'!assertSupplierHasCorrectAddresses: aSupplier	self assertPartyHasCorrectAddresses: aSupplier. ! !!SupplierImportTest methodsFor: 'asserting' stamp: 'LJ 11/21/2017 23:19'!assert: aSupplier isNamed: aName andIsIdentifiedAs: anId andNumberOfAddresses: aNumberOfAddresses andNumberOfCustomers: aNumberOfCustomers	self assert: aSupplier name equals: aName.	self assert: (aSupplier isIdentifiedAs: anId). 	self assert: aSupplier numberOfAddresses equals: aNumberOfAddresses.	self assert: aSupplier numberOfCustomers equals: aNumberOfCustomers.! !!SupplierImportTest methodsFor: 'asserting' stamp: 'LJ 11/21/2017 23:20'!assertSupplierHasCorrectCustomers: aSupplier	| pepeSanchezIdentification patoLucasIdentification |	pepeSanchezIdentification := Identification		ofType: testData alwaysImportedCustomerIdType		numbered: testData alwaysImportedCustomerIdNumber.	patoLucasIdentification := Identification		ofType: 'D'		numbered: '1234'.	self		assert: aSupplier		hasCustomerIdentifiedAs: pepeSanchezIdentification		named: 'Pepe'		lastName: 'Sanchez'.	self		assert: aSupplier		hasCustomerIdentifiedAs: patoLucasIdentification		named: 'Pato'		lastName: 'Lucas'! !!SupplierImportTest methodsFor: 'asserting' stamp: 'LJ 11/21/2017 23:26'!assertSupplier1WasImportedCorrectly		|supplier identification|		identification := 	(Identification ofType: testData  alwaysImportedSupplierIdType  numbered: testData alwaysImportedSupplierNumber ).	supplier := self supplierIdentifiedAs: identification .		self assert: supplier 		 isNamed: 'Supplier1'		 andIsIdentifiedAs: identification		 andNumberOfAddresses: 2		 andNumberOfCustomers: 2.			self assertSupplierHasCorrectAddresses: supplier.	self assertSupplierHasCorrectCustomers: supplier.! !!SupplierImportTest methodsFor: 'asserting' stamp: 'LJ 11/21/2017 23:27'!assert: aSupplier hasCustomerIdentifiedAs: anId named: aName lastName: aLastName	| customer |		customer := aSupplier customerIdentifiedAs: anId ifNone: [ self fail ].	self assert: (customer firstName) equals: aName.	self assert: (customer lastName) equals: aLastName.	! !!SupplierImportTest methodsFor: 'asserting' stamp: 'LJ 11/21/2017 23:21'!assert: customer isNamed: firstName lastName: lastName identfiedAs: idType withNumber: idNumber andNumberOfAddresses: addressesSize	self assert: customer firstName equals: firstName.	self assert: customer lastName equals: lastName.	self assert: (customer isIdentifiedAs: (Identification ofType: idType numbered: idNumber)).	self assert: customer numberOfAddresses equals: addressesSize! !!SupplierImportTest methodsFor: 'asserting' stamp: 'LJ 11/21/2017 23:17'!assertImportedSuppliersSizeIsCorrect	self assert: system allSuppliersSize equals: 1! !!SupplierImportTest methodsFor: 'asserting' stamp: 'LJ 11/21/2017 23:22'!assertPartyHasCorrectAddresses: aParty	self		assert: aParty		hasAddressAt: 'San Martin'		number: 3322		in: 'Olivos'		zipCode: 1636		province: 'BsAs'.	self		assert: aParty		hasAddressAt: 'Maipu'		number: 888		in: 'Florida'		zipCode: 1122		province: 'Buenos Aires'! !!SupplierImportTest methodsFor: 'asserting' stamp: 'LJ 11/21/2017 23:18'!assertImportedCustomersSizeIsCorrect	self assert: system allCustomersSize equals: 2! !!SupplierImportTest methodsFor: 'importing' stamp: 'LJ 11/22/2017 23:39'!importCustomersFrom: inputStream	(CsvImporter		from: inputStream		withImporter: (CustomerImporter withSystem: system)) import! !!SupplierImportTest methodsFor: 'importing' stamp: 'LJ 11/22/2017 23:39'!importSuppliersFrom: inputStream	(CsvImporter		from: inputStream		withImporter: (SupplierImporter withSystem: system)) import! !!SupplierImportTest methodsFor: 'identification' stamp: 'LJ 11/21/2017 23:23'!supplierIdentifiedAs: anId	^ system supplierIdentifiedAs: anId! !Object subclass: #ClassMapping	instanceVariableNames: 'mappedClass mappings tableName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-PersistanceModel'!!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:40'!map: anObject using: aDataBaseSession

	| record |

	self toDo: 'se puede optimizar usando array para registros y guardando definicion de tabla una vez'.
	record := Dictionary new.
	
	self mapIdOf: anObject into: record using: aDataBaseSession.
	self mapEmbededOf: anObject into: record.
	"agrego aca el registro y no luego de mapear el id para que lo agrege completo. Lo agrego antes de mapear las rel one to many 
	porque si usuara una db de verdad habria foreign key constrain"
	aDataBaseSession add: record on: self tableName.
	self mapOneToManyRelationshipsOf: anObject using: aDataBaseSession! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:42'!unmap: aRecord using: aDataBaseSession

	| unMappedObject |

	unMappedObject := mappedClass basicNew.
	self unmapIdOf: aRecord into: unMappedObject.
	self unmap: aRecord into: unMappedObject using: aDataBaseSession.

	^ unMappedObject! !!ClassMapping methodsFor: 'table' stamp: 'HernanWilkinson 10/31/2016 23:25'!tableName
	
	^tableName ! !!ClassMapping methodsFor: 'testing' stamp: 'HernanWilkinson 10/31/2016 23:02'!isFor: aClass

	^mappedClass = aClass! !!ClassMapping methodsFor: 'mapping - private' stamp: 'LJ 11/21/2017 21:19'!assertHasIdInstanceVariable: aClass 
	
	(aClass classThatDefinesInstanceVariable: #id) ifNil: [ self error: ('<1s> has no id instance variable' expandMacrosWith: aClass name) ]

! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapEmbededOf: anObject into: record

	mappings do: [ :aMapping | aMapping embeded: anObject into: record ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession

	mappings do: [ :aMapping | aMapping mapOneToManyRelationshipsOf: anObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmapIdOf: aRecord into: unMappedObject

	unMappedObject instVarNamed: #id put: (aRecord at: #id)! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmap: aRecord into: unMappedObject using: aDataBaseSession

	mappings do: [ :aMapping | aMapping unmap: aRecord into: unMappedObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapIdOf: anObject into: record using: aDataBaseSession

	| newId |

	newId := aDataBaseSession newIdFor: anObject.
	anObject instVarNamed: #id put: newId.
	record at: #id put: newId! !!ClassMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:25'!initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings

	mappedClass := aClass.
	tableName := aTableName.
	mappings := aCollectionOfMappings ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ClassMapping class	instanceVariableNames: ''!!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidTableName: aTableName

	aTableName trimBoth isEmpty ifTrue: [ self error: 'Table name can not be empty' ]! !!ClassMapping class methodsFor: 'assertions' stamp: 'LJ 11/21/2017 21:26'!assertHasIdInstanceVariable: aClass
	(aClass classThatDefinesInstanceVariable: #id) ifNil: [ self error: ('<1s> has no id instance variable' expandMacrosWith: aClass name) ]! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 19:26'!assertValidMappings: aCollectionOfMappings for: aClass 

	self toDo: 'Lo mejor seria recolectar todos los erroes de mapeo y no parar en el primero'.
	aCollectionOfMappings do: [ :aMapping | aMapping assertIsValidFor: aClass ]
	! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:24'!for: aClass into: aTableName mappingAll: aCollectionOfMappings

	self assertValidTableName: aTableName.
	self assertHasIdInstanceVariable: aClass.
	self assertValidMappings: aCollectionOfMappings for: aClass.
	
	^self new initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings


		! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:44'!defaultTableNameFor: aClass
	
	^aClass name asString! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:23'!withDefaultTableNameFor: aClass mappingAll: aCollectionOfMappings

	^self for: aClass into: (self defaultTableNameFor: aClass) mappingAll: aCollectionOfMappings

		! !Object subclass: #DataBaseSession	instanceVariableNames: 'configuration tables id cache'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-PersistanceModel'!!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:15'!objectIdentifiedAs: anId ofType: aClass

	self assertInTransaction.
	self delay.
	
	^ cache at: anId ifAbsentPut: [ self unmapRecordIdentifiedAs: anId ofType: aClass ]! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 10/31/2016 22:17'!selectAllOfType: aClass 
	
	^self select: [ :anObject | true ] ofType: aClass! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:26'!select: aCondition ofType: aClass

	| mapper table |

	self assertInTransaction.
	self delay.
	
	mapper := self mapperFor: aClass.
	table := tables at: mapper tableName ifAbsent: [ ^ #() ].
	
	^ table inject: OrderedCollection new into: [ :selected :record | self addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertInTransaction
	
	cache isNil ifTrue: [ self error: 'There is no transaction currently' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!beginTransaction

	self assertIsOpen.
	self assertNotInTransasction.
	
	cache := WeakKeyDictionary new.
	
! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!commit
	
	self assertInTransaction.
	
	cache := nil! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertNotInTransasction
	
	cache notNil ifTrue: [ self error: 'There is an open transaction already' ]! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:41'!delay

	(Delay forMilliseconds: 100) wait! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:35'!defineIdOf: anObject

	anObject instVarNamed: 'id' put: (self newIdFor: anObject).! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:04'!recordId: aRecord

	^aRecord at: #id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 10/28/2016 16:35'!newIdFor: anObject

	id := id + 1.
	^id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:00'!idOf: anObject

	^anObject instVarNamed: #id! !!DataBaseSession methodsFor: 'selecting - private' stamp: 'HernanWilkinson 11/1/2016 01:28'!addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper

	| recordId aClassInstance |

	recordId := self recordId: record.
	aClassInstance := cache at: recordId ifAbsent: [ mapper unmap: record using: self ].
	(aCondition value: aClassInstance) ifTrue: [ 
		self addToCache: aClassInstance.
		selected add: aClassInstance ].
	
	^ selected! !!DataBaseSession methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 22:55'!initializeFor: aConfiguration

	configuration := aConfiguration.
	id := 0.

	tables := nil.
	cache := nil.! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:10'!relatedIdsOwnedBy: anOwner forType: aRelatedClass

	| relatedIds table |

	table := self relationTableFor: anOwner class relatedTo: aRelatedClass.
	relatedIds := self relatedIdOwnedBy: anOwner on: table.
	
	^ relatedIds! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:06'!relatedIdOwnedBy: anOwner on: table

	^ table at: (self idOf: anOwner) ifAbsentPut: [ Set new ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:00'!signalRelationAlreadyExistBetween: anOwner and: aRelated 

	self error: ('Relation between id <1s> of type <2s> and id <3s> of type <4s> already exist'
		expandMacrosWith: (self idOf: anOwner) printString
		with: anOwner class name
		with: (self idOf: aRelated) printString
		with: aRelated class name)! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:05'!assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds

	(relatedIds includes: relatedId) ifTrue: [ self signalRelationAlreadyExistBetween: anOwner and: aRelated ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!addRelated: aRelated ownedBy: anOwner

	| relatedIds relatedId |

	relatedIds := self relatedIdsOwnedBy: anOwner forType: aRelated class.
	relatedId := aRelated instVarNamed: #id.
	self assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds.
	
	relatedIds add: relatedId! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!add: aRecord on: aTableName

	| table existingRecord |

	table := self tableNamed: aTableName.
	existingRecord := table at: (self recordId: aRecord) ifAbsentPut: [ aRecord ].
	existingRecord == aRecord ifFalse: [ self error: 'Duplicated primary key' ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:27'!addToCache: anObject 

	cache at: (self idOf: anObject) put: anObject ! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:14'!mapperFor: aClass

	self toDo: 'se puede mejorar performanco usando un dictionary'.
	^configuration
		detect: [ :aClassMapper | aClassMapper isFor: aClass ] 
		ifNone: [ self error: ('There is no mapper for <1s>' expandMacrosWith: aClass name) ]! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:16'!unmapRecordIdentifiedAs: anId ofType: aClass

	| record table mapper |

	mapper := self mapperFor: aClass.
	table := self tableNamed: mapper tableName.
	record := table at: id ifAbsent: [ self error: ('Object identified as <1s> does not exist' expandMacrosWith: anId printString) ].
	
	^ mapper unmap: record using: self! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:15'!relatedOfType: aRelatedClass for: anOwner

	| table relatedIds |
	
	table := self relationTableFor: anOwner class relatedTo: aRelatedClass.
	relatedIds := table at: (self idOf: anOwner) ifAbsent: [ ^#() ].
	
	^relatedIds collect: [ :aRelatedId | self objectIdentifiedAs: aRelatedId ofType: aRelatedClass ]
	

	! !!DataBaseSession methodsFor: 'persistance' stamp: 'LJ 11/23/2017 01:27'!addObject: anObject
	| mapper |
	self assertInTransaction.
	self delay.
	mapper := self mapperFor: anObject class.
	mapper map: anObject using: self.
	self addToCache: anObject! !!DataBaseSession methodsFor: 'persistance' stamp: 'LJ 11/23/2017 01:28'!addSupplier: aSupplier
	self addObject: aSupplier .! !!DataBaseSession methodsFor: 'persistance' stamp: 'LJ 11/23/2017 01:28'!addCustomer: aCustomer
	self addObject: aCustomer .! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 00:48'!tableNamed: aTableName

	^ tables at: aTableName ifAbsentPut: [ Dictionary new ]! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableFor: anOwnerClass relatedTo: aRelatedClass

	| relationTableName table |

	relationTableName := self relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass.
	table := self tableNamed: relationTableName.
	
	^ table! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass

	| ownerClassMapper relatedClassMapper |
	
	ownerClassMapper := self mapperFor: anOwnerClass.
	relatedClassMapper := self mapperFor: aRelatedClass.
	
	^ownerClassMapper tableName,'_', relatedClassMapper tableName asPlural.! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!open

	self assertIsClose.
	
	tables := Dictionary new.
	! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:37'!assertIsClose
	
	tables isNil ifFalse: [ self error: 'Session must be close' ]! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 22:14'!close

	self assertIsOpen.
	
	tables := nil! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!assertIsOpen
	
	tables isNil ifTrue: [ self error: 'Session must be open to colaborate with it' ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DataBaseSession class	instanceVariableNames: ''!!DataBaseSession class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/28/2016 13:07'!for: aConfiguration

	^self new initializeFor: aConfiguration! !Object subclass: #Mapping	instanceVariableNames: 'instanceVariableName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-PersistanceModel'!!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!embeded: anObject into: aRecord
	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!unmap: aRecord into: anObject using: aDataBaseSession
	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession
	self subclassResponsibility! !!Mapping methodsFor: 'assertions' stamp: 'LJ 11/21/2017 21:19'!assertIsValidFor: aClass 

	(aClass classThatDefinesInstanceVariable: instanceVariableName) ifNil: [ 
		self error: ('Invalid mapping for <1s> in class <2s>' expandMacrosWith: instanceVariableName with: aClass name) ] 	
! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Mapping class	instanceVariableNames: ''!!Mapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidFieldName: aFieldName

	aFieldName trimBoth isEmpty ifTrue: [ self error: 'Field name can not be empty' ]! !!Mapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 01:32'!defaultFieldNameFor: anInstanceVariableName

	^anInstanceVariableName asString! !Mapping subclass: #EmbededMapping	instanceVariableNames: 'fieldName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-PersistanceModel'!!EmbededMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:30'!initializeFor: anInstanceVariableName into: aFieldName

	instanceVariableName := anInstanceVariableName.
	fieldName := aFieldName ! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!embeded: anObject into: aRecord

	aRecord at: fieldName put: (anObject instVarNamed: instanceVariableName) ! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!unmap: aRecord into: anObject using: aDataBaseSession 

	anObject instVarNamed: instanceVariableName put: (aRecord at: fieldName)! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:23'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession 
	
	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EmbededMapping class	instanceVariableNames: ''!!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:29'!withDefaultFieldNameFor: anInstanceVariableName

	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName)! !!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:30'!for: anInstanceVariableName into: aFieldName

	^self new initializeFor: anInstanceVariableName into: aFieldName ! !Mapping subclass: #OneToManyMapping	instanceVariableNames: 'relatedType fieldName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-PersistanceModel'!!OneToManyMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:34'!initializeFor: anInstanceVariableName into: aFieldName ofType: aClass

	instanceVariableName := anInstanceVariableName.
	fieldName := aFieldName.
	relatedType := aClass ! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession

	| oldCollection newCollection |

	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.
	oldCollection := anObject instVarNamed: instanceVariableName.
	
	newCollection addAll: oldCollection.
	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:16'!embeded: anObject into: aRecord
	! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!unmap: aRecord into: anObject using: aDataBaseSession

	| newCollection related |

	related := aDataBaseSession relatedOfType: relatedType for: anObject.
	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.

	newCollection addAllNotPersisting: related.
	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:35'!createRelationCollectionOn: aDataBaseSession ownedBy: anObject
	^ OneToManySet on: aDataBaseSession ownedBy: anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManyMapping class	instanceVariableNames: ''!!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:40'!for: anInstanceVariableName into: aFieldName ofType: aClass

	self assertValidFieldName: aFieldName.
	
	^self new initializeFor: anInstanceVariableName into: aFieldName ofType: aClass! !!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:32'!withDefaultFieldNameFor: anInstanceVariableName ofType: aClass

	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName) ofType: aClass! !Set subclass: #OneToManySet	instanceVariableNames: 'session owner'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-PersistanceModel'!!OneToManySet methodsFor: 'removing' stamp: 'HernanWilkinson 10/31/2016 21:35'!remove: anObject ifAbsent: anAbsentBlock

	self shouldBeImplemented ! !!OneToManySet methodsFor: 'initialization' stamp: 'HernanWilkinson 11/1/2016 00:11'!initializeOn: aDataBaseSession ownedBy: anOwner
	
	session := aDataBaseSession.
	owner := anOwner ! !!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:03'!addAllNotPersisting: aCollection 
	
	^aCollection do: [ :anObjectToAdd | super add: anObjectToAdd ]! !!OneToManySet methodsFor: 'adding' stamp: 'LJ 11/16/2017 19:00'!add: anObject

	session addCustomer: anObject.
	session addRelated: anObject ownedBy: owner.
	
	super add: anObject.
! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManySet class	instanceVariableNames: ''!!OneToManySet class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:11'!on: aDataBaseSession ownedBy: anOwner
	
	^self new initializeOn: aDataBaseSession ownedBy: anOwner ! !Object subclass: #Address	instanceVariableNames: 'id streetName streetNumber town zipCode province'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetName	^streetName ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetNumber	^streetNumber ! !!Address methodsFor: 'town' stamp: 'HernanWilkinson 10/28/2016 16:12'!town	^town! !!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:13'!zipCode	^zipCode! !!Address methodsFor: 'initialization' stamp: 'LJ 11/19/2017 10:26'!withStreetName: aStreetName streetNumber: aStreetNumber town: aTown zipCode: aZipCode province: aProvince	streetName := aStreetName.	streetNumber := aStreetNumber.	town := aTown.	zipCode := aZipCode.	province := aProvince.! !!Address methodsFor: 'comparing' stamp: 'LJ 11/19/2017 10:27'!isAt: aStreetName	^streetName = aStreetName! !!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:11'!province	^province! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Address class	instanceVariableNames: ''!!Address class methodsFor: 'instance creation' stamp: 'LJ 11/19/2017 10:22'!withStreetName: aStreetName streetNumber: aStreetNumber town: aTown zipCode: aZipCode province: aProvince 	^ super new withStreetName: aStreetName streetNumber: aStreetNumber town: aTown zipCode: aZipCode province: aProvince.! !Object subclass: #CsvImporter	instanceVariableNames: 'line readStream record newParty system lineImporters importer'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!CsvImporter methodsFor: 'importing' stamp: 'HernanWilkinson 11/1/2016 17:51'!import	[ self canImportNextLine ] whileTrue: [ 		self convertLineToRecord.		self importRecord ]! !!CsvImporter methodsFor: 'access' stamp: 'LJ 11/20/2017 11:12'!record	^ record.! !!CsvImporter methodsFor: 'assertions' stamp: 'HernanWilkinson 11/2/2016 15:55'!assertRecordNotEmpty		record isEmpty ifTrue: [ self signalInvalidRecordType ]! !!CsvImporter methodsFor: 'initialization' stamp: 'LJ 11/22/2017 23:08'!initializeOn: aReadStream withImporter: anImporter 	readStream := aReadStream.	importer := anImporter .! !!CsvImporter methodsFor: 'importing - private' stamp: 'HernanWilkinson 11/2/2016 15:54'!convertLineToRecord	record := line substrings: {$,}.		self assertRecordNotEmpty! !!CsvImporter methodsFor: 'importing - private' stamp: 'LJ 11/22/2017 23:13'!importRecord	(importer imports: record) ifTrue: [ importer import: record ] ifFalse: [ self signalInvalidRecordType ].! !!CsvImporter methodsFor: 'importing - private' stamp: 'HernanWilkinson 11/2/2016 10:55'!canImportNextLine	line := readStream nextLine.	^ line notNil! !!CsvImporter methodsFor: 'error signal' stamp: 'HernanWilkinson 11/1/2016 17:54'!signalInvalidRecordType	self error: self class invalidRecordTypeErrorDescription! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CsvImporter class	instanceVariableNames: ''!!CsvImporter class methodsFor: 'instance creation' stamp: 'LJ 11/22/2017 23:07'!from: aReadStream withImporter: anImporter	^ self new initializeOn: aReadStream withImporter: anImporter . ! !!CsvImporter class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 11/1/2016 17:54'!invalidRecordTypeErrorDescription		^'Invalid record type'! !Object subclass: #CustomerSystem	instanceVariableNames: 'session'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!CustomerSystem methodsFor: 'testing' stamp: 'LJ 11/16/2017 19:05'!allCustomersIsEmpty	^ self subclassResponsibility! !!CustomerSystem methodsFor: 'adding' stamp: 'LJ 11/16/2017 19:00'!addCustomer: aCustomer	^ self subclassResponsibility.! !!CustomerSystem methodsFor: 'access' stamp: 'LJ 11/16/2017 19:02'!allCustomersSize	 ^ self subclassResponsibility .! !!CustomerSystem methodsFor: 'access' stamp: 'LJ 11/19/2017 15:52'!customerIdentifiedAs: anId	self subclassResponsibility.! !!CustomerSystem methodsFor: 'control' stamp: 'LJ 11/13/2017 21:14'!stop	^ self subclassResponsibility.! !!CustomerSystem methodsFor: 'control' stamp: 'LJ 11/13/2017 20:52'!beginTransaction	^ self subclassResponsibility.! !!CustomerSystem methodsFor: 'control' stamp: 'LJ 11/13/2017 20:51'!start	^ self subclassResponsibility.! !!CustomerSystem methodsFor: 'control' stamp: 'LJ 11/13/2017 20:51'!commit	^ self subclassResponsibility.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CustomerSystem class	instanceVariableNames: ''!!CustomerSystem class methodsFor: 'error messages' stamp: 'LJ 11/23/2017 01:15'!customerDoesNotExistError	^ 'a customer with specified identification does not exist'! !!CustomerSystem class methodsFor: 'error messages' stamp: 'LJ 11/23/2017 01:15'!alreadyTakenIdentificationError	^ 'A customer with specified identification already exists'! !Object subclass: #Environment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Environment methodsFor: 'creation' stamp: 'LJ 11/19/2017 11:47'!createErpSystem	^ self subclassResponsibility .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Environment class	instanceVariableNames: ''!!Environment class methodsFor: 'testing' stamp: 'LJ 11/13/2017 20:41'!isCurrent	^ self subclassResponsibility .! !!Environment class methodsFor: 'accessing' stamp: 'LJ 11/13/2017 20:43'!current	^ self subclasses detect: [:aSubclass | aSubclass isCurrent ]  ifFound: [:aSubclass | aSubclass new ]  ifNone: [ self error: self noEnvironmentFoundErrorMessage ] .! !!Environment class methodsFor: 'error messages' stamp: 'LJ 11/13/2017 20:39'!noEnvironmentFoundErrorMessage	^ 'No environment found'! !Environment subclass: #DevelopmentEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!DevelopmentEnvironment methodsFor: 'creation' stamp: 'LJ 11/19/2017 11:52'!createErpSystem	^ ErpSystem withCustomerSystem: TransientCustomerSystem new supplierSystem: TransientSupplierSystem new.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DevelopmentEnvironment class	instanceVariableNames: ''!!DevelopmentEnvironment class methodsFor: 'testing' stamp: 'LJ 11/13/2017 20:41'!isCurrent	^ IntegrationEnvironment isCurrent not.! !Object subclass: #ErpSystem	instanceVariableNames: 'customerSystem supplierSystem session'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!ErpSystem methodsFor: 'setUp - tearDown' stamp: 'LJ 11/19/2017 12:23'!stop	supplierSystem stop.	customerSystem stop.! !!ErpSystem methodsFor: 'setUp - tearDown' stamp: 'LJ 11/19/2017 12:22'!beginTransaction	customerSystem beginTransaction.	supplierSystem beginTransaction.! !!ErpSystem methodsFor: 'setUp - tearDown' stamp: 'LJ 11/19/2017 12:22'!start	customerSystem start.	supplierSystem start.! !!ErpSystem methodsFor: 'setUp - tearDown' stamp: 'LJ 11/19/2017 12:22'!commit	customerSystem commit.	supplierSystem commit.! !!ErpSystem methodsFor: 'initialization' stamp: 'LJ 11/19/2017 11:53'!withCustomerSystem: aCustomerSystem supplierSystem: aSupplierSystem	customerSystem := aCustomerSystem.	supplierSystem := aSupplierSystem.! !!ErpSystem methodsFor: 'testing' stamp: 'LJ 11/21/2017 23:46'!allSuppliersIsEmpty	^ supplierSystem allSuppliersIsEmpty ! !!ErpSystem methodsFor: 'testing' stamp: 'LJ 11/19/2017 12:36'!allCustomersIsEmpty	^ customerSystem allCustomersIsEmpty! !!ErpSystem methodsFor: 'access' stamp: 'LJ 11/20/2017 19:52'!allSuppliersSize	^ supplierSystem allSuppliersSize! !!ErpSystem methodsFor: 'access' stamp: 'LJ 11/19/2017 12:36'!allCustomersSize	^ customerSystem allCustomersSize! !!ErpSystem methodsFor: 'access' stamp: 'LJ 11/20/2017 21:51'!supplierIdentifiedAs: anIdentification	^ supplierSystem supplierIdentifiedAs: anIdentification! !!ErpSystem methodsFor: 'access' stamp: 'LJ 11/20/2017 11:45'!customerIdentifiedAs: anIdentification	^ customerSystem customerIdentifiedAs: anIdentification! !!ErpSystem methodsFor: 'adding' stamp: 'LJ 11/19/2017 12:24'!addCustomer: aCustomer	customerSystem addCustomer: aCustomer.! !!ErpSystem methodsFor: 'adding' stamp: 'LJ 11/20/2017 19:53'!addSupplier: aSupplier	supplierSystem addSupplier: aSupplier! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ErpSystem class	instanceVariableNames: ''!!ErpSystem class methodsFor: 'instance creation' stamp: 'LJ 11/19/2017 11:53'!withCustomerSystem: aCustomerSystem supplierSystem: aSupplierSystem	^ self new withCustomerSystem: aCustomerSystem supplierSystem: aSupplierSystem.! !Object subclass: #Identification	instanceVariableNames: 'id identificationType identificationNumber'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Identification methodsFor: 'initialization' stamp: 'LJ 11/20/2017 22:06'!ofType: anIdentificationType numbered: anIdentificationNumber	identificationType := anIdentificationType.	identificationNumber := anIdentificationNumber ! !!Identification methodsFor: 'comparing' stamp: 'LJ 11/19/2017 16:10'!= anId	^ identificationType = anId identificationType and: [ identificationNumber = anId identificationNumber ]! !!Identification methodsFor: 'accessing' stamp: 'LJ 11/19/2017 16:10'!identificationNumber	^ identificationNumber! !!Identification methodsFor: 'accessing' stamp: 'LJ 11/19/2017 16:10'!identificationType	^ identificationType.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Identification class	instanceVariableNames: ''!!Identification class methodsFor: 'instance creation' stamp: 'LJ 11/20/2017 22:06'!ofType: anIdentificationType numbered: anIdentificationNumber	^ self new ofType: anIdentificationType numbered: anIdentificationNumber.! !Object subclass: #Importer	instanceVariableNames: 'system recordImporters'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Importer methodsFor: 'importing' stamp: 'LJ 11/22/2017 23:38'!import: aRecord	recordImporters detect: [:aLineImporter | aLineImporter imports: aRecord ] ifFound: [:aLineImporter | aLineImporter import: aRecord on: self ]. ! !!Importer methodsFor: 'testing' stamp: 'LJ 11/22/2017 23:38'!imports: aRecord	^ recordImporters anySatisfy: [:aLineImporter | aLineImporter imports: aRecord ].! !Importer subclass: #CustomerImporter	instanceVariableNames: 'lastAddedCustomer'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!CustomerImporter methodsFor: 'asserting' stamp: 'LJ 11/22/2017 23:24'!assertThereIsCustomerForAddress	lastAddedCustomer ifNil: [ self error: self class noCustomerBeforeAddressError ]! !!CustomerImporter methodsFor: 'adding' stamp: 'LJ 11/22/2017 23:02'!addCustomer: aCustomer	lastAddedCustomer := aCustomer.	system addCustomer: aCustomer! !!CustomerImporter methodsFor: 'adding' stamp: 'LJ 11/22/2017 23:03'!addAddress: anAddress	self assertThereIsCustomerForAddress.	lastAddedCustomer addAddress: anAddress! !!CustomerImporter methodsFor: 'initialization' stamp: 'LJ 11/22/2017 23:38'!withSystem: aSystem	system := aSystem .	recordImporters := OrderedCollection		with: AddressRecordImporter new		with: CustomerRecordImporter new.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CustomerImporter class	instanceVariableNames: ''!!CustomerImporter class methodsFor: 'instance creation' stamp: 'LJ 11/22/2017 22:53'!withSystem: aSystem	^ self new withSystem: aSystem .! !!CustomerImporter class methodsFor: 'error messages' stamp: 'LJ 11/22/2017 23:05'!noCustomerBeforeAddressError	^ 'A customer needs to be present before importing addresses'! !Environment subclass: #IntegrationEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!IntegrationEnvironment methodsFor: 'creation' stamp: 'LJ 11/21/2017 22:05'!createErpSystem	| mappingSystem |	mappingSystem := MappingSystem new.	^ ErpSystem withCustomerSystem: (PersistentCustomerSystem withSystemMapping: mappingSystem) supplierSystem: (PersistentSupplierSystem withMappingSystem: mappingSystem).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!IntegrationEnvironment class	instanceVariableNames: ''!!IntegrationEnvironment class methodsFor: 'testing' stamp: 'LJ 11/23/2017 01:28'!isCurrent	^ false! !Object subclass: #MappingSystem	instanceVariableNames: 'mappings'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!MappingSystem methodsFor: 'mapping' stamp: 'LJ 11/21/2017 21:57'!supplierMapping	^ ClassMapping		withDefaultTableNameFor: Supplier		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #name)				with: (EmbededMapping withDefaultFieldNameFor: #id)				with: (OneToManyMapping withDefaultFieldNameFor: #customers ofType: Customer)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !!MappingSystem methodsFor: 'mapping' stamp: 'LJ 11/21/2017 22:00'!allMappings	^ (Array				with: (self addressMapping )				with: (self customerMapping )				with: (self supplierMapping ))! !!MappingSystem methodsFor: 'mapping' stamp: 'LJ 11/21/2017 21:57'!customerMapping	^ ClassMapping		withDefaultTableNameFor: Customer		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #firstName)				with: (EmbededMapping withDefaultFieldNameFor: #lastName)				with: (EmbededMapping withDefaultFieldNameFor: #identification)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !!MappingSystem methodsFor: 'mapping' stamp: 'LJ 11/21/2017 21:57'!addressMapping	^ ClassMapping		withDefaultTableNameFor: Address		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #streetName)				with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)				with: (EmbededMapping withDefaultFieldNameFor: #town)				with: (EmbededMapping withDefaultFieldNameFor: #zipCode)				with: (EmbededMapping withDefaultFieldNameFor: #province))! !Object subclass: #Party	instanceVariableNames: 'id identification addresses'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Party methodsFor: 'comparing' stamp: 'LJ 11/20/2017 09:28'!isIdentifiedAs: anId	^ identification = anId.! !!Party methodsFor: 'adding' stamp: 'LJ 11/20/2017 09:51'!addAddress: anAddress 	addresses add: anAddress ! !!Party methodsFor: 'access' stamp: 'LJ 11/22/2017 23:51'!identification	^ identification! !!Party methodsFor: 'access' stamp: 'LJ 11/20/2017 09:53'!numberOfAddresses		^addresses size! !!Party methodsFor: 'access' stamp: 'LJ 11/20/2017 09:51'!addressAt: aStreetName ifNone: noneClosure 		^addresses detect: [ :anAddress | anAddress isAt: aStreetName ] ifNone: noneClosure ! !!Party methodsFor: 'testing' stamp: 'LJ 11/20/2017 09:51'!addressesIsEmpty		^addresses isEmpty! !Party subclass: #Customer	instanceVariableNames: 'firstName lastName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Customer methodsFor: 'access' stamp: 'HernanWilkinson 10/28/2016 16:15'!lastName	^lastName ! !!Customer methodsFor: 'access' stamp: 'HernanWilkinson 10/28/2016 16:15'!firstName		^firstName ! !!Customer methodsFor: 'initialization' stamp: 'LJ 11/20/2017 09:27'!withFirstName: aFirstName lastName: aLastName identification: anIdentification	super initialize.	firstName := aFirstName.	lastName := aLastName.	identification := anIdentification.	addresses := OrderedCollection new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Customer class	instanceVariableNames: ''!!Customer class methodsFor: 'instance creation' stamp: 'LJ 11/19/2017 16:29'!withFirstName: aFirstName lastName: aLastName identification: anIdentification	^ super new withFirstName: aFirstName lastName: aLastName identification: anIdentification! !CustomerSystem subclass: #PersistentCustomerSystem	instanceVariableNames: 'mappingSystem'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!PersistentCustomerSystem methodsFor: 'control' stamp: 'LJ 11/13/2017 20:23'!commit	session commit.! !!PersistentCustomerSystem methodsFor: 'control' stamp: 'LJ 11/13/2017 20:22'!beginTransaction	session beginTransaction.! !!PersistentCustomerSystem methodsFor: 'control' stamp: 'LJ 11/21/2017 22:03'!start	session := DataBaseSession for: mappingSystem allMappings.	session open! !!PersistentCustomerSystem methodsFor: 'control' stamp: 'LJ 11/13/2017 21:14'!stop	session close.! !!PersistentCustomerSystem methodsFor: 'testing' stamp: 'LJ 11/16/2017 19:05'!allCustomersIsEmpty	^ self allCustomersSize = 0.! !!PersistentCustomerSystem methodsFor: 'access' stamp: 'LJ 11/16/2017 19:03'!allCustomersSize	^ (session selectAllOfType: Customer) size.! !!PersistentCustomerSystem methodsFor: 'access' stamp: 'LJ 11/22/2017 00:23'!customerIdentifiedAs: anId	| customers |	customers := session		select: [ :aCustomer | aCustomer isIdentifiedAs: anId]		ofType: Customer.	customers size = 0		ifTrue: [ self error: CustomerSystem customerDoesNotExistError ].	^ customers anyOne! !!PersistentCustomerSystem methodsFor: 'initialization' stamp: 'LJ 11/21/2017 22:03'!initializeWith: aMappingSystem	mappingSystem := aMappingSystem! !!PersistentCustomerSystem methodsFor: 'adding' stamp: 'LJ 11/23/2017 00:16'!addCustomer: aCustomer	| customers |	customers := session select: [ :anotherCustomer | anotherCustomer isIdentifiedAs: aCustomer identification ] ofType: Customer.	customers size = 0		ifTrue: [ session addCustomer: aCustomer ]		ifFalse: [ self error: CustomerSystem alreadyTakenIdentificationError ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PersistentCustomerSystem class	instanceVariableNames: ''!!PersistentCustomerSystem class methodsFor: 'instance creation' stamp: 'LJ 11/21/2017 22:04'!withSystemMapping: aSystemMapping	^ self new initializeWith: aSystemMapping.! !Object subclass: #RecordImporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!RecordImporter methodsFor: 'testing' stamp: 'LJ 11/20/2017 10:50'!imports: aRecord	^self subclassResponsibility! !!RecordImporter methodsFor: 'error signal' stamp: 'LJ 11/20/2017 11:07'!signalInvalidRecord	^ self subclassResponsibility! !!RecordImporter methodsFor: 'asserting' stamp: 'LJ 11/20/2017 11:06'!assertValidRecordSize: aRecord	^ self subclassResponsibility! !!RecordImporter methodsFor: 'importing' stamp: 'LJ 11/22/2017 23:16'!import: aRecord on: anImporter	^ self subclassResponsibility! !RecordImporter subclass: #AddressRecordImporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!AddressRecordImporter methodsFor: 'importing' stamp: 'LJ 11/22/2017 23:16'!import: aRecord on: anImporter	self assertValidRecordSize: aRecord.	^ anImporter		addAddress:			(Address				withStreetName: aRecord second				streetNumber: aRecord third asInteger				town: aRecord fourth				zipCode: aRecord fifth asInteger				province: aRecord sixth)! !!AddressRecordImporter methodsFor: 'testing' stamp: 'LJ 11/20/2017 10:51'!imports: aRecord	^ aRecord first = 'A'! !!AddressRecordImporter methodsFor: 'asserting' stamp: 'LJ 11/20/2017 11:06'!assertValidRecordSize: aRecord	aRecord size ~= 6		ifTrue: [ self signalInvalidRecord ]! !!AddressRecordImporter methodsFor: 'error signal' stamp: 'LJ 11/20/2017 11:07'!signalInvalidRecord	self error: self class invalidAddressRecordErrorDescription! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AddressRecordImporter class	instanceVariableNames: ''!!AddressRecordImporter class methodsFor: 'error descriptions' stamp: 'LJ 11/20/2017 11:01'!invalidAddressRecordErrorDescription	^ 'Invalid address record'! !RecordImporter subclass: #CustomerRecordImporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!CustomerRecordImporter methodsFor: 'asserting' stamp: 'LJ 11/20/2017 11:06'!assertValidRecordSize: aRecord	aRecord size ~= 5		ifTrue: [ self signalInvalidRecord ]! !!CustomerRecordImporter methodsFor: 'testing' stamp: 'LJ 11/20/2017 10:51'!imports: aRecord	^ aRecord first = 'C'! !!CustomerRecordImporter methodsFor: 'importing' stamp: 'LJ 11/22/2017 23:17'!import: aRecord on: anImporter	self assertValidRecordSize: aRecord.	anImporter		addCustomer:			(Customer				withFirstName: aRecord second				lastName: aRecord third				identification: (Identification ofType: aRecord fourth numbered: aRecord fifth))! !!CustomerRecordImporter methodsFor: 'error signal' stamp: 'LJ 11/20/2017 11:07'!signalInvalidRecord	self error: self class invalidCustomerRecordErrorDescription! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CustomerRecordImporter class	instanceVariableNames: ''!!CustomerRecordImporter class methodsFor: 'error descriptions' stamp: 'LJ 11/20/2017 10:41'!invalidCustomerRecordErrorDescription	^ 'Invalid customer record'! !RecordImporter subclass: #ExistingCustomerRecordImporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!ExistingCustomerRecordImporter methodsFor: 'asserting' stamp: 'LJ 11/20/2017 11:37'!assertValidRecordSize: aRecord	aRecord size ~= 3		ifTrue: [ self signalInvalidRecord ]! !!ExistingCustomerRecordImporter methodsFor: 'error signal' stamp: 'LJ 11/20/2017 11:37'!signalInvalidRecord	self error: self class invalidExistingCustomerRecordErrorDescription! !!ExistingCustomerRecordImporter methodsFor: 'importing' stamp: 'LJ 11/22/2017 23:43'!import: aRecord on: anImporter	self assertValidRecordSize: aRecord.	anImporter addExistingCustomerWithIdentification: (Identification ofType: aRecord second numbered: aRecord third)! !!ExistingCustomerRecordImporter methodsFor: 'testing' stamp: 'LJ 11/20/2017 20:00'!imports: aRecord	^ aRecord first = 'EC'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ExistingCustomerRecordImporter class	instanceVariableNames: ''!!ExistingCustomerRecordImporter class methodsFor: 'error descriptions' stamp: 'LJ 11/20/2017 11:38'!invalidExistingCustomerRecordErrorDescription	^ 'Invalid existing customer record'! !RecordImporter subclass: #NewCustomerRecordImporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!NewCustomerRecordImporter methodsFor: 'testing' stamp: 'LJ 11/20/2017 20:00'!imports: aRecord	^ aRecord first = 'NC'! !!NewCustomerRecordImporter methodsFor: 'asserting' stamp: 'LJ 11/20/2017 11:37'!assertValidRecordSize: aRecord	aRecord size ~= 5		ifTrue: [ self signalInvalidRecord ]! !!NewCustomerRecordImporter methodsFor: 'error signal' stamp: 'LJ 11/20/2017 11:37'!signalInvalidRecord	self error: self class invalidNewCustomerRecordErrorDescription! !!NewCustomerRecordImporter methodsFor: 'importing' stamp: 'LJ 11/22/2017 23:41'!import: aRecord on: anImporter	self assertValidRecordSize: aRecord.	anImporter		addNewCustomer:			(Customer				withFirstName: aRecord second				lastName: aRecord third				identification: (Identification ofType: aRecord fourth numbered: aRecord fifth))! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!NewCustomerRecordImporter class	instanceVariableNames: ''!!NewCustomerRecordImporter class methodsFor: 'error descriptions' stamp: 'LJ 11/20/2017 11:38'!invalidNewCustomerRecordErrorDescription	^ 'Invalid new customer record'! !Party subclass: #Supplier	instanceVariableNames: 'name customers'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Supplier methodsFor: 'initializing' stamp: 'LJ 11/23/2017 00:32'!withName: aName identification: anIdentification	name := aName.	identification := anIdentification.	customers := OrderedCollection new.	addresses := OrderedCollection new.! !!Supplier methodsFor: 'accessing' stamp: 'LJ 11/20/2017 22:54'!customerIdentifiedAs: anId ifNone: noneClosure 		^customers detect: [ :aCustomer | aCustomer isIdentifiedAs: anId ] ifNone: noneClosure ! !!Supplier methodsFor: 'accessing' stamp: 'LJ 11/19/2017 15:03'!numberOfCustomers	^ customers size! !!Supplier methodsFor: 'accessing' stamp: 'LJ 11/19/2017 10:03'!name	^ name! !!Supplier methodsFor: 'testing' stamp: 'LJ 11/19/2017 15:05'!customersIsEmpty	^ customers isEmpty! !!Supplier methodsFor: 'adding' stamp: 'LJ 11/19/2017 15:04'!addCustomer: aCustomer	^ customers add: aCustomer! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Supplier class	instanceVariableNames: ''!!Supplier class methodsFor: 'instance creation' stamp: 'LJ 11/20/2017 09:37'!withName: aName identification: anIdentification	^ self new withName: aName identification: anIdentification.! !Importer subclass: #SupplierImporter	instanceVariableNames: 'lastAddedSupplier'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!SupplierImporter methodsFor: 'asserting' stamp: 'LJ 11/22/2017 23:30'!assertThereIsSupplierForNewCustomer	self throwErrorIfSupplierIsNill: self class noSupplierBeforeNewCustomerError ! !!SupplierImporter methodsFor: 'asserting' stamp: 'LJ 11/22/2017 23:30'!assertThereIsSupplierForAddress	self throwErrorIfSupplierIsNill: self class noSupplierBeforeAddressesError.! !!SupplierImporter methodsFor: 'asserting' stamp: 'LJ 11/22/2017 23:30'!assertThereIsSupplierForExistingCustomer	self throwErrorIfSupplierIsNill:self class noSupplierBeforeExistingCustomerError! !!SupplierImporter methodsFor: 'error handling' stamp: 'LJ 11/22/2017 23:30'!throwErrorIfSupplierIsNill: anError	lastAddedSupplier ifNil: [ self error: anError ]! !!SupplierImporter methodsFor: 'initialization' stamp: 'LJ 11/22/2017 23:38'!withSystem: aSystem	system := aSystem.	recordImporters := (OrderedCollection with: (AddressRecordImporter new) with: (ExistingCustomerRecordImporter new)	with: (NewCustomerRecordImporter new) with: (SupplierRecordImporter new)) ! !!SupplierImporter methodsFor: 'adding' stamp: 'LJ 11/22/2017 23:22'!addAddress: anAddress	self assertThereIsSupplierForAddress.	lastAddedSupplier addAddress: anAddress! !!SupplierImporter methodsFor: 'adding' stamp: 'LJ 11/22/2017 23:33'!addSupplier: aSupplier	lastAddedSupplier := aSupplier.	system addSupplier: aSupplier! !!SupplierImporter methodsFor: 'adding' stamp: 'LJ 11/22/2017 23:29'!addExistingCustomerWithIdentification: anIdentification	self assertThereIsSupplierForExistingCustomer .	lastAddedSupplier addCustomer: (system customerIdentifiedAs: anIdentification).	! !!SupplierImporter methodsFor: 'adding' stamp: 'LJ 11/22/2017 23:28'!addNewCustomer: aCustomer	self assertThereIsSupplierForNewCustomer.	system addCustomer: aCustomer.	lastAddedSupplier addCustomer: aCustomer.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SupplierImporter class	instanceVariableNames: ''!!SupplierImporter class methodsFor: 'instance creation' stamp: 'LJ 11/22/2017 23:21'!withSystem: aSystem	^ self new withSystem: aSystem.! !!SupplierImporter class methodsFor: 'error messages' stamp: 'LJ 11/22/2017 23:32'!noSupplierBeforeExistingCustomerError	^ 'A supplier needs to be present before importing existing customer'! !!SupplierImporter class methodsFor: 'error messages' stamp: 'LJ 11/22/2017 23:24'!noSupplierBeforeAddressesError	^ 'A supplier needs to be present before importing addresses'! !!SupplierImporter class methodsFor: 'error messages' stamp: 'LJ 11/22/2017 23:32'!noSupplierBeforeNewCustomerError	^ 'A supplier needs to be present before importing new customer'! !RecordImporter subclass: #SupplierRecordImporter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!SupplierRecordImporter methodsFor: 'importing' stamp: 'LJ 11/22/2017 23:42'!import: aRecord on: anImporter	self assertValidRecordSize: aRecord.	^ anImporter		addSupplier:			(Supplier				withName: aRecord second 				identification: (Identification ofType: aRecord third 				numbered: aRecord fourth)				)! !!SupplierRecordImporter methodsFor: 'asserting' stamp: 'LJ 11/20/2017 11:22'!assertValidRecordSize: aRecord	aRecord size ~= 4		ifTrue: [ self signalInvalidRecord ]! !!SupplierRecordImporter methodsFor: 'error signal' stamp: 'LJ 11/20/2017 11:23'!signalInvalidRecord	self error: self class invalidSupplierRecordErrorDescription	! !!SupplierRecordImporter methodsFor: 'testing' stamp: 'LJ 11/20/2017 10:51'!imports: aRecord	^ aRecord first = 'S'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SupplierRecordImporter class	instanceVariableNames: ''!!SupplierRecordImporter class methodsFor: 'error descriptions' stamp: 'LJ 11/20/2017 11:23'!invalidSupplierRecordErrorDescription	^ 'Invalid supplier record'! !Object subclass: #SupplierSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!SupplierSystem methodsFor: 'adding' stamp: 'LJ 11/19/2017 15:32'!addSupplier: aSupplier	^ self subclassResponsibility! !!SupplierSystem methodsFor: 'access' stamp: 'LJ 11/19/2017 15:52'!supplierIdentifiedAs: anId	^ self subclassResponsibility! !!SupplierSystem methodsFor: 'access' stamp: 'LJ 11/19/2017 15:34'!allSuppliersSize	self subclassResponsibility! !!SupplierSystem methodsFor: 'testing' stamp: 'LJ 11/19/2017 15:34'!allSuppliersIsEmpty	self subclassResponsibility! !!SupplierSystem methodsFor: 'control' stamp: 'LJ 11/19/2017 15:31'!commit	^ self subclassResponsibility! !!SupplierSystem methodsFor: 'control' stamp: 'LJ 11/19/2017 15:31'!beginTransaction	^ self subclassResponsibility.! !!SupplierSystem methodsFor: 'control' stamp: 'LJ 11/19/2017 15:31'!start	^ self subclassResponsibility! !!SupplierSystem methodsFor: 'control' stamp: 'LJ 11/19/2017 15:31'!stop	^ self subclassResponsibility! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SupplierSystem class	instanceVariableNames: ''!!SupplierSystem class methodsFor: 'error messages' stamp: 'LJ 11/23/2017 01:15'!alreadyTakenIdentificationError	^ 'A supplier with specified identification already exists'! !SupplierSystem subclass: #PersistentSupplierSystem	instanceVariableNames: 'session mappingSystem'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!PersistentSupplierSystem methodsFor: 'adding' stamp: 'LJ 11/23/2017 01:27'!addSupplier: aSupplier	| suppliers |	suppliers := session select: [ :anotherSupplier | anotherSupplier isIdentifiedAs: aSupplier identification ] ofType: Supplier.	suppliers size = 0		ifTrue: [ session addSupplier: aSupplier ]		ifFalse: [ self error: SupplierSystem alreadyTakenIdentificationError ]! !!PersistentSupplierSystem methodsFor: 'testing' stamp: 'LJ 11/19/2017 15:37'!allSuppliersIsEmpty	^ self allSuppliersSize = 0! !!PersistentSupplierSystem methodsFor: 'control' stamp: 'LJ 11/19/2017 14:34'!stop	session close! !!PersistentSupplierSystem methodsFor: 'control' stamp: 'LJ 11/19/2017 14:33'!beginTransaction	session beginTransaction! !!PersistentSupplierSystem methodsFor: 'control' stamp: 'LJ 11/21/2017 22:02'!start	session := DataBaseSession for: mappingSystem allMappings.	session open! !!PersistentSupplierSystem methodsFor: 'control' stamp: 'LJ 11/19/2017 14:33'!commit	session commit! !!PersistentSupplierSystem methodsFor: 'access' stamp: 'LJ 11/19/2017 15:51'!supplierIdentifiedAs: anId	| suppliers |	suppliers := session		select: [ :aSupplier | aSupplier isIdentifiedAs: anId ]		ofType: Supplier.	suppliers size = 1		ifFalse: [ self error: 'There should be just one client identified.' ].	^ suppliers anyOne! !!PersistentSupplierSystem methodsFor: 'access' stamp: 'LJ 11/19/2017 15:38'!allSuppliersSize	^ (session selectAllOfType: Supplier) size! !!PersistentSupplierSystem methodsFor: 'initialization' stamp: 'LJ 11/21/2017 22:03'!initializeWith: aMappingSystem	mappingSystem := aMappingSystem.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PersistentSupplierSystem class	instanceVariableNames: ''!!PersistentSupplierSystem class methodsFor: 'as yet unclassified' stamp: 'LJ 11/21/2017 22:02'!withMappingSystem: aMappingSystem	^ self new initializeWith: aMappingSystem.! !CustomerSystem subclass: #TransientCustomerSystem	instanceVariableNames: 'customers'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!TransientCustomerSystem methodsFor: 'access' stamp: 'LJ 11/16/2017 19:03'!allCustomersSize	^ customers size.! !!TransientCustomerSystem methodsFor: 'access' stamp: 'LJ 11/22/2017 00:23'!customerIdentifiedAs: anId	| customer |	customer := customers select: [ :aCustomer | aCustomer isIdentifiedAs: anId ].	customer size = 0		ifTrue: [ self error: CustomerSystem customerDoesNotExistError ].	^ customer anyOne! !!TransientCustomerSystem methodsFor: 'control' stamp: 'LJ 11/13/2017 21:03'!commit! !!TransientCustomerSystem methodsFor: 'control' stamp: 'LJ 11/13/2017 21:02'!beginTransaction! !!TransientCustomerSystem methodsFor: 'control' stamp: 'LJ 11/13/2017 21:12'!start	customers := OrderedCollection new.! !!TransientCustomerSystem methodsFor: 'control' stamp: 'LJ 11/13/2017 21:14'!stop! !!TransientCustomerSystem methodsFor: 'testing' stamp: 'LJ 11/23/2017 00:16'!addCustomer: aCustomer	| customer |	customer := customers select: [ :anotherCustomer | anotherCustomer isIdentifiedAs: aCustomer identification ].	customer size = 0		ifTrue: [ customers add: aCustomer ]		ifFalse: [ self error: CustomerSystem alreadyTakenIdentificationError ]! !!TransientCustomerSystem methodsFor: 'testing' stamp: 'LJ 11/16/2017 19:06'!allCustomersIsEmpty	^ self allCustomersSize = 0.! !SupplierSystem subclass: #TransientSupplierSystem	instanceVariableNames: 'suppliers'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!TransientSupplierSystem methodsFor: 'control' stamp: 'LJ 11/19/2017 12:28'!stop	! !!TransientSupplierSystem methodsFor: 'control' stamp: 'LJ 11/19/2017 12:27'!beginTransaction	! !!TransientSupplierSystem methodsFor: 'control' stamp: 'LJ 11/20/2017 19:59'!start	suppliers := OrderedCollection new.	! !!TransientSupplierSystem methodsFor: 'control' stamp: 'LJ 11/19/2017 12:28'!commit! !!TransientSupplierSystem methodsFor: 'access' stamp: 'LJ 11/20/2017 22:21'!supplierIdentifiedAs: anId	| supplier |	supplier := suppliers select: [ :aSupplier | aSupplier isIdentifiedAs: anId ].	supplier size = 1		ifFalse: [ self error: 'There should be just one supplier identified.' ].	^ supplier anyOne! !!TransientSupplierSystem methodsFor: 'access' stamp: 'LJ 11/19/2017 15:33'!allSuppliersSize	^ suppliers size.! !!TransientSupplierSystem methodsFor: 'testing' stamp: 'LJ 11/19/2017 15:33'!allSuppliersIsEmpty	^ suppliers isEmpty.! !!TransientSupplierSystem methodsFor: 'adding' stamp: 'LJ 11/23/2017 01:17'!addSupplier: aSupplier	| supplier |	supplier := suppliers select: [ :anotherSupplier| anotherSupplier isIdentifiedAs: aSupplier identification ].	supplier size = 0		ifTrue: [ suppliers add: aSupplier ]		ifFalse: [ self error: SupplierSystem alreadyTakenIdentificationError ]! !'From Pharo6.0 of 13 May 2016 [Latest update: #60519] on 23 November 2017 at 1:29:18.260044 am'!!String methodsFor: '*10Pines-C17-2' stamp: 'HernanWilkinson 10/31/2016 23:57'!asPlural
	
	^self last = $s 
		ifTrue: [ self, 'es' ]
		ifFalse: [ self, 's' ]! !'From Pharo6.0 of 13 May 2016 [Latest update: #60519] on 23 November 2017 at 1:29:18.300044 am'!!Object methodsFor: '*10Pines-C17-2' stamp: 'HernanWilkinson 10/31/2016 19:27'!toDo: aString 
	! !